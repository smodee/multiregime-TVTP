% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/score_functions.R
\name{apply_moore_penrose_scaling}
\alias{apply_moore_penrose_scaling}
\title{Apply Moore-Penrose pseudo-inverse scaling to raw score vector}
\usage{
apply_moore_penrose_scaling(raw_score, fisher_info, method = "simple")
}
\arguments{
\item{raw_score}{Raw score vector from calculate_raw_score_vector() (length K*(K-1))}

\item{fisher_info}{Fisher Information scalar from calculate_fisher_information()}

\item{method}{Scaling method ("moore_penrose", "simple", or "normalized")}
}
\value{
Scaled score vector (length K*(K-1))
}
\description{
Apply Moore-Penrose pseudo-inverse scaling to raw score vector
}
\details{
Applies proper scaling to the raw score vector using the Moore-Penrose
pseudo-inverse approach described in Bazzi et al. (2017), equation (15).

Since the Fisher Information matrix is singular by design (as noted in the paper),
we use the Moore-Penrose pseudo-inverse for scaling. The original 2-regime
implementation uses: s_t = S_t * r_t, where S_t is related to the square root
of the pseudo-inverse.

Following the original implementation: S_star = S1 / sqrt(I), where:
\itemize{
\item S1 is the raw score component
\item I is the Fisher Information
}

For the K-regime case, we generalize this by:
\enumerate{
\item Normalizing the raw score vector
\item Scaling by the inverse square root of Fisher Information
\item Applying additional normalization for numerical stability
}
}
\examples{
# Apply scaling to a raw score vector
raw_score <- c(0.1, -0.2, 0.05, -0.1, 0.15, -0.05)  # 6 elements for 3-regime model
fisher_info <- 2.5

scaled_score <- apply_moore_penrose_scaling(raw_score, fisher_info)

# Use simple scaling method
scaled_score <- apply_moore_penrose_scaling(raw_score, fisher_info, method = "simple")
}
